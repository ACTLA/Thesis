# 2.2. Реализация модуля управления камерой

Модуль управления камерой является критически важным компонентом системы, обеспечивающим стабильный захват видеопотока и его распределение между различными компонентами приложения. Реализация в файле `camera_manager.py` построена на принципах надежности и производительности с учетом специфики работы с видеооборудованием в различных операционных системах.

## Архитектура менеджера камеры

Класс `CameraManager` реализован как синглтон для обеспечения единственного экземпляра во всей системе. Это решение предотвращает конфликты доступа к аппаратным ресурсам камеры и обеспечивает централизованное управление видеопотоком. Инициализация менеджера происходит однократно при первом обращении к экземпляру класса.

Основное состояние камеры контролируется через флаг `_is_running`, который синхронизируется между потоками с использованием механизмов блокировки. Это обеспечивает корректную работу при одновременном доступе из разных частей системы.

```python
def __init__(self):
    super().__init__()
    self._is_running = False
    self._cap = None
    self._capture_thread = None
    self._frame_callbacks = []
    self._callbacks_lock = threading.Lock()
```

Система подписки на кадры позволяет различным компонентам приложения получать видеоданные без дублирования процесса захвата. Компоненты регистрируют функции обратного вызова, которые автоматически вызываются при поступлении новых кадров с камеры.

## Инициализация и настройка камеры

Процесс запуска камеры включает попытки подключения с различными видеобэкендами для обеспечения максимальной совместимости. Система начинает с DirectShow в Windows, затем пробует Video4Linux в Linux и наконец универсальные драйвера.

```python
def start_camera(self) -> bool:
    backends = [cv2.CAP_DSHOW, cv2.CAP_ANY]
    
    for backend in backends:
        try:
            self._cap = cv2.VideoCapture(self.camera_index, backend)
            if self._cap.isOpened():
                break
        except Exception as e:
            continue
```

После успешного подключения система настраивает параметры камеры согласно конфигурации. Устанавливается разрешение съемки, частота кадров и размер буфера для минимизации задержек. Система адаптируется к возможностям конкретного оборудования, используя максимально возможные параметры.

Проверка работоспособности включает попытку захвата тестового кадра для подтверждения корректности инициализации. Только после успешного получения кадра система переходит к запуску основного потока обработки.

## Основной цикл захвата кадров

Захват видеопотока выполняется в отдельном потоке для предотвращения блокировки пользовательского интерфейса. Поток работает в непрерывном цикле, читая кадры с камеры и распространяя их между подписанными компонентами.

Контроль ошибок в цикле захвата обеспечивает стабильную работу при временных сбоях видеосигнала. Система подсчитывает последовательные ошибки и прекращает работу только при превышении критического порога, что позволяет переживать кратковременные проблемы с оборудованием.

```python
def _capture_loop(self):
    consecutive_errors = 0
    max_consecutive_errors = 10
    
    while self._is_running:
        try:
            ret, frame = self._cap.read()
            if not ret:
                consecutive_errors += 1
                if consecutive_errors >= max_consecutive_errors:
                    break
                continue
            
            consecutive_errors = 0
            self._distribute_frame(frame)
            
        except Exception as e:
            consecutive_errors += 1
```

Распределение кадров между подписчиками выполняется через защищенный механизм вызова функций обратного вызова. Каждый подписчик получает копию кадра для предотвращения конфликтов при одновременной обработке разными компонентами.

## Управление ресурсами

Корректное освобождение ресурсов камеры критически важно для стабильности системы. При остановке работы система ожидает завершения потока захвата с таймаутом и принудительно завершает его при превышении времени ожидания.

```python
def stop_camera(self):
    self._is_running = False
    
    if self._capture_thread and self._capture_thread.is_alive():
        self._capture_thread.join(timeout=3.0)
        if self._capture_thread.is_alive():
            # Поток не завершился в отведенное время
            pass
    
    self._cleanup_camera()
```

Очистка ресурсов включает освобождение объекта камеры OpenCV и сброс внутренних буферов. Система обрабатывает возможные исключения при освобождении ресурсов, что предотвращает зависание приложения при проблемах с драйверами камеры.

Деструктор класса автоматически вызывает остановку камеры при завершении работы приложения, обеспечивая корректное освобождение ресурсов даже при аварийном завершении программы.

## Интеграция с пользовательским интерфейсом

Передача кадров в пользовательский интерфейс осуществляется через систему Qt сигналов для обеспечения потокобезопасности. Специальный таймер с частотой обновления 30 кадров в секунду обеспечивает плавное отображение видео без перегрузки интерфейса.

Последний кадр сохраняется в защищенной переменной для доступа из основного потока GUI. Это решение предотвращает блокировки и обеспечивает стабильную частоту обновления отображения независимо от скорости обработки кадров.

Информация о состоянии камеры предоставляется через метод `get_camera_info()`, который возвращает текущие параметры работы, статус подключения и диагностическую информацию для отображения в интерфейсе пользователя.

Такая реализация модуля управления камерой обеспечивает надежную основу для всей системы распознавания лиц и создает стабильную платформу для интеграции алгоритмов компьютерного зрения.