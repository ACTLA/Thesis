# 3.1. Проектирование структуры базы данных

Система управления данными построена на реляционной базе данных SQLite, которая обеспечивает надежное хранение информации без необходимости развертывания отдельного сервера баз данных. Выбор SQLite обусловлен простотой развертывания, высокой производительностью для настольных приложений и встроенной поддержкой транзакций ACID.

## Архитектура базы данных

Структура базы данных реализована в файле `database.py` и спроектирована с учетом принципов нормализации для предотвращения дублирования данных и обеспечения целостности информации. Основные таблицы включают администраторов системы, пользователей для распознавания и журналы событий распознавания.

Таблица администраторов содержит учетные записи лиц, имеющих доступ к управлению системой. Структура включает уникальный идентификатор, имя пользователя, адрес электронной почты, хэш пароля с индивидуальной солью и временные метки создания и последнего входа в систему.

```python
def _create_database(self):
    with self.get_connection() as conn:
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS admins (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT UNIQUE NOT NULL,
                email TEXT NOT NULL,
                password_hash TEXT NOT NULL,
                salt TEXT NOT NULL,
                is_active INTEGER DEFAULT 1,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                last_login TIMESTAMP NULL
            )
        ''')
```

Таблица пользователей хранит информацию о лицах, зарегистрированных в системе для распознавания. Каждая запись включает персональные данные, путь к фотографии, биометрический шаблон в JSON формате и метаданные о процессе регистрации.

Журнал событий распознавания фиксирует каждый случай идентификации пользователя с детальной информацией о времени, результате и уровне уверенности системы. Эта таблица критически важна для анализа работы системы и аудита безопасности.

## Хранение биометрических данных

Биометрические шаблоны лиц представляют собой 128-элементные численные векторы, которые сохраняются в базе данных в формате JSON. Такое решение обеспечивает читаемость данных и простоту обработки, хотя создает потенциальные риски безопасности при компрометации базы данных.

```python
def add_user(self, user_data: Dict, created_by: int) -> Optional[int]:
    try:
        with self.get_connection() as conn:
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT INTO users 
                (user_id, full_name, email, phone, photo_path, face_encoding, created_by)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (
                user_data['user_id'],
                user_data['full_name'],
                user_data.get('email', ''),
                user_data.get('phone', ''),
                user_data.get('photo_path', ''),
                json.dumps(user_data.get('face_encoding', [])),
                created_by
            ))
```

Индексирование биометрических данных выполняется по ключевым полям для ускорения операций поиска. Создаются индексы по идентификатору пользователя, статусу активности и временным меткам для оптимизации часто выполняемых запросов.

Контроль целостности биометрических данных обеспечивается через ограничения уникальности и внешние ключи. Система предотвращает создание дублирующихся записей пользователей и обеспечивает ссылочную целостность между связанными таблицами.

## Система аутентификации

Безопасность аутентификации администраторов обеспечивается через современные методы хеширования паролей. Система использует PBKDF2 с SHA-256 и 100000 итераций для создания стойких хешей с индивидуальными солями для каждой учетной записи.

```python
def _hash_password(self, password: str, salt: str) -> str:
    return hashlib.pbkdf2_hmac(
        'sha256',
        password.encode('utf-8'),
        salt.encode('utf-8'),
        100000
    ).hex()
    
def _create_default_admin(self):
    with self.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT id FROM admins WHERE username = ?", (DEFAULT_ADMIN_USERNAME,))
        
        if not cursor.fetchone():
            salt = secrets.token_hex(32)
            password_hash = self._hash_password(DEFAULT_ADMIN_PASSWORD, salt)
            
            cursor.execute('''
                INSERT INTO admins (username, email, password_hash, salt)
                VALUES (?, ?, ?, ?)
            ''', (
                DEFAULT_ADMIN_USERNAME,
                'admin@company.com',
                password_hash,
                salt
            ))
```

Создание администратора по умолчанию происходит автоматически при первом запуске системы. Проверка существования предотвращает дублирование записей при повторных инициализациях базы данных.

## Журналирование операций

Система журналирования событий распознавания обеспечивает детальную регистрацию всех операций идентификации. Каждая запись включает ссылку на пользователя, временную метку, уровень уверенности и тип события.

```python
def add_recognition_log(self, user_id: int, confidence: float, recognition_type: str = 'SUCCESS') -> Optional[int]:
    try:
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO recognition_logs (user_id, confidence, recognition_type)
                VALUES (?, ?, ?)
            ''', (user_id, confidence, recognition_type))
            
            log_id = cursor.lastrowid
            conn.commit()
            return log_id
    except Exception as e:
        return None
```

Статистические запросы обеспечивают быстрое получение агрегированных данных для отображения в интерфейсе. Методы подсчета событий за день и уникальных пользователей используют SQL функции для эффективной обработки больших объемов данных.

## Управление соединениями и транзакциями

Менеджер контекста для соединений с базой данных обеспечивает корректное управление ресурсами и автоматическое закрытие соединений. Использование контекстного менеджера предотвращает утечки ресурсов при исключениях.

```python
@contextmanager
def get_connection(self):
    with self._lock:
        try:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            conn.row_factory = sqlite3.Row
            conn.execute("PRAGMA foreign_keys = ON")
            yield conn
        except Exception as e:
            raise
        finally:
            conn.close()
```

Блокировка потоков через `threading.RLock()` обеспечивает потокобезопасный доступ к базе данных из различных компонентов системы. Повторно входящие блокировки позволяют одному потоку выполнять вложенные операции с базой данных.

Таймаут соединения в 30 секунд предотвращает зависание приложения при блокировках базы данных. Включение внешних ключей через PRAGMA обеспечивает автоматическую проверку ссылочной целостности при выполнении операций.

Такая архитектура базы данных обеспечивает надежное хранение данных системы распознавания лиц и создает основу для интеграции дополнительных функций безопасности в будущих версиях системы.