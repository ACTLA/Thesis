# 3.3. Система аутентификации администраторов

Система аутентификации обеспечивает безопасный доступ к административным функциям управления системой распознавания лиц. Реализация включает современные методы защиты паролей, пользовательский интерфейс с элементами безопасности и интеграцию с основным приложением.

## Архитектура окна входа

Класс `LoginWindow` в файле `ui/login_window.py` реализует адаптивный интерфейс входа с фиксированными размерами для обеспечения предсказуемого отображения на различных устройствах. Окно автоматически центрируется на экране и включает все необходимые элементы для безопасной аутентификации.

Интерфейс построен на вертикальном размещении компонентов с логическим разделением на области ввода учетных данных и элементы управления. Поля ввода имеют увеличенную высоту и современное стилевое оформление для удобства использования.

```python
def init_ui(self):
    self.setWindowTitle("Вход - Система распознавания лиц")
    window_width, window_height = 500, 600
    
    self.resize(window_width, window_height)
    self.center_on_screen()
    
    # Поля ввода
    self.username_input = QLineEdit()
    self.username_input.setPlaceholderText("Введите имя пользователя")
    self.username_input.setMinimumHeight(50)
    
    self.password_input = QLineEdit()
    self.password_input.setPlaceholderText("Введите пароль")
    self.password_input.setEchoMode(QLineEdit.Password)
    self.password_input.setMinimumHeight(50)
```

Система поддерживает вход по клавише Enter через подключение сигнала `returnPressed` к методу обработки аутентификации для обоих полей ввода. Автоматическое заполнение полей значениями по умолчанию упрощает первоначальный доступ к системе.

## Процесс аутентификации

Метод `handle_login` выполняет комплексную проверку введенных учетных данных с предварительной валидацией на клиентской стороне. Система проверяет заполненность полей и блокирует интерфейс во время выполнения проверки для предотвращения множественных попыток.

```python
def handle_login(self):
    username = self.username_input.text().strip()
    password = self.password_input.text()
    
    if not username or not password:
        QMessageBox.warning(self, "Предупреждение", "Пожалуйста, заполните все поля")
        return
    
    # Блокировка интерфейса
    self.login_button.setEnabled(False)
    self.login_button.setText("Проверка...")
    
    # Аутентификация
    admin_data = self.db.authenticate_admin(username, password)
    
    # Восстановление интерфейса
    self.login_button.setEnabled(True)
    self.login_button.setText("Войти в систему")
    
    if admin_data:
        self.login_successful.emit(admin_data)
        self.close()
    else:
        QMessageBox.critical(self, "Ошибка", "Неверное имя пользователя или пароль")
        self.password_input.clear()
        self.shake_animation()
```

Визуальная обратная связь включает изменение текста кнопки входа на "Проверка..." и временную деактивацию для информирования пользователя о выполняющемся процессе. При неудачной аутентификации поле пароля автоматически очищается и получает фокус ввода.

## Криптографическая защита паролей

Система аутентификации использует современный алгоритм PBKDF2 с хешированием SHA-256 для защиты паролей администраторов. Реализация в классе `Database` обеспечивает криптографически стойкую защиту учетных данных.

```python
def _hash_password(self, password: str, salt: str) -> str:
    return hashlib.pbkdf2_hmac(
        'sha256',
        password.encode('utf-8'),
        salt.encode('utf-8'),
        100000
    ).hex()

def authenticate_admin(self, username: str, password: str) -> Optional[Dict]:
    try:
        with self.get_connection() as conn:
            cursor = conn.cursor()
            
            cursor.execute('''
                SELECT id, username, email, password_hash, salt, is_active
                FROM admins WHERE username = ?
            ''', (username,))
            
            admin = cursor.fetchone()
            if not admin or not admin['is_active']:
                return None
            
            # Проверка пароля
            password_hash = self._hash_password(password, admin['salt'])
            if password_hash != admin['password_hash']:
                return None
            
            # Обновление времени входа
            cursor.execute('''
                UPDATE admins SET last_login = ? WHERE id = ?
            ''', (datetime.now(), admin['id']))
            
            return {
                'id': admin['id'],
                'username': admin['username'],
                'email': admin['email']
            }
    except Exception as e:
        return None
```

Генерация уникальной соли для каждого администратора выполняется через модуль `secrets` с использованием криптографически стойкого генератора случайных чисел. Соль длиной 64 символа обеспечивает защиту от атак по радужным таблицам.

Процесс проверки пароля включает создание хеша введенного пароля с сохраненной солью и сравнение результата с хешем из базы данных. Использование постоянного времени выполнения предотвращает атаки по времени выполнения.

## Управление сессиями и аудит

Успешная аутентификация автоматически обновляет поле `last_login` в записи администратора текущей временной меткой. Это создает аудиторский след входов в систему для анализа активности и выявления подозрительных действий.

Проверка активности учетной записи через поле `is_active` позволяет временно блокировать администраторов без удаления их данных из системы. Неактивные учетные записи отклоняются на этапе аутентификации.

Передача минимально необходимых данных администратора в основное приложение ограничивает распространение чувствительной информации. Возвращаемый словарь включает только идентификатор, имя пользователя и адрес электронной почты.

## Визуальные элементы безопасности

Анимация встряхивания при неудачном входе привлекает внимание к ошибке аутентификации и обеспечивает четкую обратную связь пользователю. Анимация выполняется через изменение позиции окна с небольшой амплитудой.

```python
def shake_animation(self):
    try:
        self.animation = QPropertyAnimation(self, b"pos")
        self.animation.setDuration(100)
        self.animation.setLoopCount(3)
        
        start_pos = self.pos()
        self.animation.setStartValue(start_pos)
        self.animation.setKeyValueAt(0.25, QPoint(start_pos.x() + 10, start_pos.y()))
        self.animation.setKeyValueAt(0.75, QPoint(start_pos.x() - 10, start_pos.y()))
        self.animation.setEndValue(start_pos)
        
        self.animation.start()
    except:
        pass
```

Стилизация элементов интерфейса включает изменение цветов при фокусе и наведении курсора для улучшения пользовательского опыта. Кнопка входа использует градиентные эффекты для визуального подтверждения интерактивности.

Обработка клавиши Escape позволяет закрыть окно входа без аутентификации, что соответствует стандартному поведению диалоговых окон в настольных приложениях.

## Интеграция с основным приложением

Сигнал `login_successful` передает данные аутентифицированного администратора в основное приложение через механизм сигналов и слотов PyQt5. Это обеспечивает слабую связанность между компонентами системы.

```python
class FaceRecognitionApp:
    def on_login_success(self, admin_data):
        if self.login_window:
            self.login_window.close()
        
        self.main_window = MainWindow(admin_data)
        self.main_window.show()
```

Автоматическое закрытие окна входа происходит при успешной аутентификации для освобождения ресурсов и предотвращения накопления неиспользуемых окон. Основное окно получает данные администратора для персонализации интерфейса.

Обработка ошибок аутентификации включает отображение понятных сообщений пользователю и автоматическую подготовку интерфейса для повторной попытки входа.

Такая реализация системы аутентификации обеспечивает базовую защиту административного доступа и создает основу для интеграции многофакторной аутентификации и расширенных механизмов безопасности в будущих версиях системы.